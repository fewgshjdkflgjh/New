<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Train Tracker â€” Fully Working</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #cfe6ff;
    font-family: Arial, sans-serif;
    user-select: none;
    touch-action: none;
  }
  #mapContainer {
    width: 100vw;
    height: 100vh;
  }
  canvas {
    width: 100%;
    height: 100%;
    cursor: grab;
  }
  canvas:active {
    cursor: grabbing;
  }
</style>
</head>
<body>
<canvas id="map" width="1920" height="1080"></canvas>
<script>
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');

// View control
let scale = 0.05; // Start zoomed out for large maps
let offsetX = canvas.width/2;
let offsetY = canvas.height/2;
let isDragging = false;
let lastMouseX, lastMouseY;
let lastTouchDistance = null;
let lastTouchMid = null;

// Data
let tracks = [];
let trainPos = null;

// --- DRAW FUNCTIONS ---
function drawSmoothTrack(ctx, points) {
  if (points.length < 2) return;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  ctx.lineWidth = 10 * scale;
  ctx.strokeStyle = '#222';
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 0; i < points.length-1; i++){
    const c = points[i];
    const n = points[i+1];
    const cx = (c.x+n.x)/2;
    const cy = (c.y+n.y)/2;
    ctx.quadraticCurveTo(c.x,c.y,cx,cy);
  }
  ctx.stroke();

  ctx.lineWidth = 5*scale;
  ctx.strokeStyle = '#666';
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 0; i < points.length-1; i++){
    const c = points[i];
    const n = points[i+1];
    const cx = (c.x+n.x)/2;
    const cy = (c.y+n.y)/2;
    ctx.quadraticCurveTo(c.x,c.y,cx,cy);
  }
  ctx.stroke();
}

function drawMap() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  // Draw each line
  tracks.forEach(line => {
    const mapped = line.points.map(p => ({x:p.x, y:-p.z}));
    drawSmoothTrack(ctx, mapped);
  });

  // Draw train
  if (trainPos){
    const x = trainPos.x;
    const y = -trainPos.z;
    ctx.fillStyle = '#ffcc00';
    ctx.beginPath();
    ctx.arc(x,y,40/scale,0,Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 5/scale;
    ctx.strokeStyle = '#000';
    ctx.stroke();
  }

  ctx.restore();
}

// --- CENTER MAP ---
function centerTracks() {
  if (!tracks.length) return;
  let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
  tracks.forEach(line => {
    line.points.forEach(p => {
      minX = Math.min(minX, p.x);
      maxX = Math.max(maxX, p.x);
      minZ = Math.min(minZ, p.z);
      maxZ = Math.max(maxZ, p.z);
    });
  });
  const centerX = (minX+maxX)/2;
  const centerZ = (minZ+maxZ)/2;
  offsetX = canvas.width/2 - centerX*scale;
  offsetY = canvas.height/2 + centerZ*scale;
}

// --- MOUSE EVENTS ---
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const zoomSpeed = 0.1;
  const prevScale = scale;
  scale *= e.deltaY<0 ? 1+zoomSpeed : 1-zoomSpeed;
  scale = Math.max(0.01,Math.min(3,scale));

  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  offsetX -= (mouseX - offsetX)*(scale/prevScale-1);
  offsetY -= (mouseY - offsetY)*(scale/prevScale-1);

  drawMap();
});

canvas.addEventListener('mousedown', e=>{
  isDragging = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});
window.addEventListener('mouseup', ()=>isDragging=false);
canvas.addEventListener('mousemove', e=>{
  if(!isDragging) return;
  offsetX += e.clientX - lastMouseX;
  offsetY += e.clientY - lastMouseY;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  drawMap();
});

// --- TOUCH EVENTS ---
function getTouchMid(t){return {x:(t[0].clientX+t[1].clientX)/2,y:(t[0].clientY+t[1].clientY)/2};}
function getTouchDist(t){return Math.hypot(t[0].clientX-t[1].clientX,t[0].clientY-t[1].clientY);}
canvas.addEventListener('touchstart', e=>{
  if(e.touches.length===1){
    lastMouseX = e.touches[0].clientX;
    lastMouseY = e.touches[0].clientY;
  } else if(e.touches.length===2){
    lastTouchDistance = getTouchDist(e.touches);
    lastTouchMid = getTouchMid(e.touches);
  }
});
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  if(e.touches.length===1){
    const dx = e.touches[0].clientX - lastMouseX;
    const dy = e.touches[0].clientY - lastMouseY;
    offsetX += dx;
    offsetY += dy;
    lastMouseX = e.touches[0].clientX;
    lastMouseY = e.touches[0].clientY;
  } else if(e.touches.length===2){
    const newDist = getTouchDist(e.touches);
    const mid = getTouchMid(e.touches);
    const zoomFactor = newDist / lastTouchDistance;
    const prevScale = scale;
    scale *= zoomFactor;
    scale = Math.max(0.01,Math.min(3,scale));
    offsetX -= (mid.x - offsetX)*(scale/prevScale-1);
    offsetY -= (mid.y - offsetY)*(scale/prevScale-1);
    lastTouchDistance = newDist;
    lastTouchMid = mid;
  }
  drawMap();
});

// --- LOAD DATA ---
fetch('tracks.json')
  .then(r=>r.json())
  .then(d=>{
    tracks = d;
    centerTracks();
    drawMap();
  });

// --- Update train ---
setInterval(()=>{
  fetch('train.json')
    .then(r=>r.json())
    .then(d=>{
      trainPos = d;
      drawMap();
    })
    .catch(()=>{});
},100);
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Train Tracker â€” Touch & Zoom</title>
<style>
  body {
    background: #cfe6ff;
    font-family: Arial, sans-serif;
    text-align: center;
    margin: 0;
    padding: 0;
    overflow: hidden;
    user-select: none;
    touch-action: none;
  }
  h1 {
    margin: 10px 0;
    font-size: 26px;
  }
  #mapContainer {
    position: relative;
    width: 100vw;
    height: 90vh;
    background: #b3d1ff;
    margin: 0 auto;
    overflow: hidden;
    border-top: 3px solid #222;
    border-bottom: 3px solid #222;
  }
  canvas {
    width: 100%;
    height: 100%;
    cursor: grab;
    touch-action: none;
  }
  canvas:active {
    cursor: grabbing;
  }
</style>
</head>
<body>
<h1>ðŸš„ Train Tracker â€” Mobile + Desktop</h1>
<div id="mapContainer">
  <canvas id="map" width="1920" height="1080"></canvas>
</div>

<script>
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');

// Data
let tracks = [];
let trainPos = null;

// View control
let scale = 0.5;
let offsetX = canvas.width / 2;
let offsetY = canvas.height / 2;

// Mouse drag
let isDragging = false;
let lastMouseX, lastMouseY;

// Touch variables
let lastTouchDistance = null;
let lastTouchMid = null;

// --- Draw functions ---
function drawSmoothTrack(ctx, points) {
  if (points.length < 2) return;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  // Outer black line
  ctx.lineWidth = 10 * scale;
  ctx.strokeStyle = '#222';
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 0; i < points.length - 1; i++) {
    const c = points[i];
    const n = points[i + 1];
    const cx = (c.x + n.x) / 2;
    const cy = (c.y + n.y) / 2;
    ctx.quadraticCurveTo(c.x, c.y, cx, cy);
  }
  ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
  ctx.stroke();

  // Inner gray
  ctx.lineWidth = 5 * scale;
  ctx.strokeStyle = '#666';
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 0; i < points.length - 1; i++) {
    const c = points[i];
    const n = points[i + 1];
    const cx = (c.x + n.x) / 2;
    const cy = (c.y + n.y) / 2;
    ctx.quadraticCurveTo(c.x, c.y, cx, cy);
  }
  ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
  ctx.stroke();
}

function drawMap() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  const mapped = tracks.map(p => ({ x: p.x, y: -p.z }));

  drawSmoothTrack(ctx, mapped);

  // Train marker
  if (trainPos) {
    const x = trainPos.x;
    const y = -trainPos.z;
    ctx.fillStyle = '#ffcc00';
    ctx.beginPath();
    ctx.arc(x, y, 40 / scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.lineWidth = 5 / scale;
    ctx.strokeStyle = '#000';
    ctx.stroke();
  }

  ctx.restore();
}

// --- Mouse zoom/pan ---
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const zoomSpeed = 0.1;
  const prevScale = scale;
  scale *= e.deltaY < 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
  scale = Math.max(0.1, Math.min(3, scale));

  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const dx = mouseX - offsetX;
  const dy = mouseY - offsetY;
  offsetX -= dx * (scale / prevScale - 1);
  offsetY -= dy * (scale / prevScale - 1);

  drawMap();
});

canvas.addEventListener('mousedown', e => {
  isDragging = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});
window.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mousemove', e => {
  if (!isDragging) return;
  offsetX += e.clientX - lastMouseX;
  offsetY += e.clientY - lastMouseY;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  drawMap();
});

// --- Touch zoom/pan ---
function getTouchMid(touches) {
  const x = (touches[0].clientX + touches[1].clientX) / 2;
  const y = (touches[0].clientY + touches[1].clientY) / 2;
  return { x, y };
}
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    lastMouseX = e.touches[0].clientX;
    lastMouseY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    lastTouchDistance = getTouchDistance(e.touches);
    lastTouchMid = getTouchMid(e.touches);
  }
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length === 1) {
    // drag pan
    const dx = e.touches[0].clientX - lastMouseX;
    const dy = e.touches[0].clientY - lastMouseY;
    offsetX += dx;
    offsetY += dy;
    lastMouseX = e.touches[0].clientX;
    lastMouseY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    // pinch zoom
    const newDist = getTouchDistance(e.touches);
    const mid = getTouchMid(e.touches);
    const zoomFactor = newDist / lastTouchDistance;
    const prevScale = scale;
    scale *= zoomFactor;
    scale = Math.max(0.1, Math.min(3, scale));

    const rect = canvas.getBoundingClientRect();
    const dx = mid.x - rect.left - offsetX;
    const dy = mid.y - rect.top - offsetY;
    offsetX -= dx * (scale / prevScale - 1);
    offsetY -= dy * (scale / prevScale - 1);

    lastTouchDistance = newDist;
    lastTouchMid = mid;
  }
  drawMap();
});

// --- Data ---
fetch('tracks.json')
  .then(r => r.json())
  .then(d => {
    tracks = d;
    drawMap();
  });

setInterval(() => {
  fetch('train.json')
    .then(r => r.json())
    .then(d => {
      trainPos = d;
      drawMap();
    })
    .catch(() => {});
}, 100);
</script>
</body>
</html>